/* Mainly taken and modified from the POSIX shell standard:
   http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html */

%{
    use strict;
    use warnings;
    use English;
    use Switch;

    sub getNextToken {
        my $token = "";

        while (length $ARG[0]->YYData->{"DATA"} > 0) {
            $ARG[0]->YYData->{"DATA"} =~ s/^([^ \t\n|;&\\'"]+)// and $token .= $1;
            my $nextChar = substr($ARG[0]->YYData->{"DATA"}, 0, 1);
            if ($nextChar eq "\\") {
                $nextChar = substr($ARG[0]->YYData->{"DATA"}, 1, 1);
                if ($nextChar ne "\n") {
                    $token .= "\\" . $nextChar;
                }
            } elsif ($nextChar eq "'") {
                if ($ARG[0]->YYData->{"DATA"} =~ s/^('[^']+')//) {
                    $token .= $1;
                } else {
                    die "unexpected EOF while looking for matching `''\n";
                }
            } elsif ($nextChar eq "\"") {
                if ($ARG[0]->YYData->{"DATA"} =~ s/^("(?:\\[\$`"\\\n]?|[^"])*")//) {
                    my $match = $1;
                    $match =~ s/\\\n//g;
                    $token .= $match;
                } else {
                    die "unexpected EOF while looking for matching `\"'\n";
                }
            } else {
                return $token;
            }
        }

        return $token;
    }

    sub Lexer {
        $ARG[0]->YYData->{"DATA"} =~ s/^[ \t]+//;
        if (length $ARG[0]->YYData->{"DATA"} == 0) {
            return ("", undef);
        }

        $ARG[0]->YYData->{"DATA"} =~ s/^(\n)// and return ("NEWLINE", $1);
        $ARG[0]->YYData->{"DATA"} =~ s/^(#.*)// and return ("SL_COMMENT", $1);
        $ARG[0]->YYData->{"DATA"} =~ s/^(&&)// and return ("AND_IF", $1);
        $ARG[0]->YYData->{"DATA"} =~ s/^(\|\|)// and return ("OR_IF", $1);
        $ARG[0]->YYData->{"DATA"} =~ s/^(;;)// and return ("DSEMI", $1);
        $ARG[0]->YYData->{"DATA"} =~ s/^(>>)// and return ("DGREAT", $1);
        $ARG[0]->YYData->{"DATA"} =~ s/^(<&)// and return ("LESSAND", $1);
        $ARG[0]->YYData->{"DATA"} =~ s/^(>&)// and return ("GREATAND", $1);
        $ARG[0]->YYData->{"DATA"} =~ s/^(<>)// and return ("LESSGREAT", $1);

        my $token = getNextToken($ARG[0]);
        if (length $token == 0) {
            if (length $ARG[0]->YYData->{"DATA"} == 0) {
                return ("", undef);
            } else {
                $ARG[0]->YYData->{"DATA"} =~ s/^(.)//;
                return ($1, $1);
            }
        }

        my $type;
        switch ($token) {
            case "if" {$type = "If";}
            case "then" {$type = "Then";}
            case "else" {$type = "Else";}
            case "elif" {$type = "Elif";}
            case "fi" {$type = "Fi";}
            case "do" {$type = "Do";}
            case "done" {$type = "Done";}
            case "case" {$type = "Case";}
            case "esac" {$type = "Esac";}
            case "while" {$type = "While";}
            case "for" {$type = "For";}
            case "!" {$type = "Bang";}
            case "in" {$type = "In";}
            case /[a-z][a-z0-9]*=/ {$type = "ASSIGNMENT_WORD";}
            case /[a-z][a-z0-9]*/ {$type = "NAME";}
            else {$type = "WORD";}
        }

        return ($type, $token);
    }

    sub createNode {
        my $type = shift @ARG;
        return {
            "type" => $type,
            "children" => grep { $_ } \@ARG
        };
    }
    sub createLeaf {
        return {
            "type" => $ARG[0],
            "value" => $ARG[1]
        };
    }
    sub appendNode {
        my $node = shift @ARG;
        push $node->{"children"}, grep { $_ } @ARG;
        return $node;
    }

    sub mergeCommand {
        my $result = shift @ARG;
        foreach my $arg (@ARG) {
            foreach my $key (keys %$arg) {
                if (!$result->{$key}) {
                    $result->{$key} = $arg->{$key};
                } else {
                    die("Merge conflict: $key\n");
                }
            }
        }
        return $result;
    }

    sub error {
        print STDERR "Error: ", $ARG[1], "\n";
        $ARG[0]->YYError();
    }
%}

/* -------------------------------------------------------
   The grammar symbols
   ------------------------------------------------------- */
%token  WORD
%token  ASSIGNMENT_WORD
%token  NAME
%token  NEWLINE
%token  IO_NUMBER
%token  SL_COMMENT

/* The following are the operators mentioned above. */

%token  AND_IF    OR_IF    DSEMI
/*      '&&'      '||'     ';;'    */

%token  DGREAT  LESSAND  GREATAND  LESSGREAT
/*      '>>'    '<&'     '>&'      '<>'      */


/* The following are the reserved words. */

%token  If    Then    Else    Elif    Fi    Do    Done
/*      'if'  'then'  'else'  'elif'  'fi'  'do'  'done'   */


%token  Case    Esac    While    For
/*      'case'  'esac'  'while'  'for'   */


/* These are reserved words, not operator tokens, and are
   recognized when reserved words are recognized. */

%token  Bang
/*      '!'   */


%token  In
/*      'in'   */

/* -------------------------------------------------------
   The Grammar
   ------------------------------------------------------- */
%start file
%%
file             : file line
                     {appendNode($ARG[1], $ARG[2]);}
                 |      line
                     {createNode("file", $ARG[1]);}
                 ;
line             : complete_command
                 | newline_list
                 ;
complete_command : list separator
                     {createNode("complete_command", $ARG[1], $ARG[2]);}
                 | list
                     {createNode("complete_command", $ARG[1]);}
                 ;
list             : list separator_op and_or
                     {appendNode($ARG[1], $ARG[3]);}
                 |                   and_or
                     {createNode("list", $ARG[1]);}
                 ;
and_or           :                         pipeline
                     {createNode("and_or", $ARG[1]);}
                 | and_or AND_IF linebreak pipeline
                     {createNode("and_or", $ARG[1], $ARG[2], $ARG[4]);}
                 | and_or OR_IF  linebreak pipeline
                     {createNode("and_or", $ARG[1], $ARG[2], $ARG[4]);}
                 ;
pipeline         :      pipe_sequence
                     {$ARG[1];}
                 | Bang pipe_sequence
                     {createLeaf("not", $ARG[2]);}
                 ;
pipe_sequence    :                             command
                     {createNode("pipe_sequence", $ARG[1]);}
                 | pipe_sequence '|' linebreak command
                     {appendNode($ARG[1], $ARG[3], $ARG[4]);}
                 ;
command          : simple_command
                     {createLeaf("simple_command", $ARG[1]);}
                 | compound_command
                     {error($ARG[0], "Compound commands currently unsupported");}
                 | compound_command redirect_list
                     {error($ARG[0], "Compound commands currently unsupported");}
                 ;
compound_command : for_clause
                 | case_clause
                 | if_clause
                 | while_clause
                 ;
compound_list    :              term
                 | newline_list term
                 |              term separator
                 | newline_list term separator
                 ;
term             : term separator and_or
                 |                and_or
                 ;
for_clause       : For name linebreak                            do_group
                 | For name linebreak in          sequential_sep do_group
                 | For name linebreak in wordlist sequential_sep do_group
                 ;
name             : NAME                     /* Apply rule 5 */
                 ;
in               : In                       /* Apply rule 6 */
                 ;
word             : WORD
                 | ASSIGNMENT_WORD
                 | NAME
                 ;
word_or_operator : word
                 | If
                 | Then
                 | Else
                 | Elif
                 | Fi
                 | Do
                 | Done
                 | Case
                 | Esac
                 | While
                 | For
                 | Bang
                 | In
                 ;
wordlist         : wordlist word
                 |          word
                 ;
case_clause      : Case word linebreak in linebreak case_list    Esac
                 | Case word linebreak in linebreak case_list_ns Esac
                 | Case word linebreak in linebreak              Esac
                 ;
case_list_ns     : case_list case_item_ns
                 |           case_item_ns
                 ;
case_list        : case_list case_item
                 |           case_item
                 ;
case_item_ns     :     pattern ')'               linebreak
                 |     pattern ')' compound_list linebreak
                 | '(' pattern ')'               linebreak
                 | '(' pattern ')' compound_list linebreak
                 ;
case_item        :     pattern ')' linebreak     DSEMI linebreak
                 |     pattern ')' compound_list DSEMI linebreak
                 | '(' pattern ')' linebreak     DSEMI linebreak
                 | '(' pattern ')' compound_list DSEMI linebreak
                 ;
pattern          :             word         /* Apply rule 4 */
                 | pattern '|' word         /* Do not apply rule 4 */
                 ;
if_clause        : If compound_list Then compound_list else_part Fi
                 | If compound_list Then compound_list           Fi
                 ;
else_part        : Elif compound_list Then compound_list else_part
                 | Elif compound_list Then compound_list
                 | Else compound_list
                 ;
while_clause     : While compound_list do_group
                 ;
do_group         : Do compound_list Done           /* Apply rule 6 */
                 ;
simple_command   : cmd_prefix cmd_word cmd_suffix
                     {mergeCommand($ARG[1], $ARG[3], {"command" => $ARG[2]});}
                 | cmd_prefix cmd_word
                     {mergeCommand($ARG[1], {"command" => $ARG[2]});}
                 | cmd_prefix
                 | cmd_name cmd_suffix
                     {mergeCommand($ARG[2], {"command" => $ARG[1]});}
                 | cmd_name
                     {{"command" => $ARG[1]};}
                 ;
cmd_name         : WORD                   /* Apply rule 7a */
                 | NAME
                 ;
cmd_word         : word                   /* Apply rule 7b */
                 ;
cmd_prefix       :            io_redirect
                     {error($ARG[0], "IO redirection currently unsupported");}
                 | cmd_prefix io_redirect
                     {error($ARG[0], "IO redirection currently unsupported");}
                 |            ASSIGNMENT_WORD
                     {{"assignment" => [$ARG[1]]};}
                 | cmd_prefix ASSIGNMENT_WORD
                     {push $ARG[1]->{"assignment"}, $ARG[2]; $ARG[1];}
                 ;
cmd_suffix       :            io_redirect
                     {error($ARG[0], "IO redirection currently unsupported");}
                 | cmd_suffix io_redirect
                     {error($ARG[0], "IO redirection currently unsupported");}
                 |            word_or_operator
                     {{"args" => [$ARG[1]]}}
                 | cmd_suffix word_or_operator
                     {push $ARG[1]->{"args"}, $ARG[2]; $ARG[1];}
                 ;
redirect_list    :               io_redirect
                 | redirect_list io_redirect
                 ;
io_redirect      :           io_file
                 | IO_NUMBER io_file
                 ;
io_file          : '<'       filename
                 | LESSAND   filename
                 | '>'       filename
                 | GREATAND  filename
                 | DGREAT    filename
                 | LESSGREAT filename
                 | CLOBBER   filename
                 ;
filename         : word                      /* Apply rule 2 */
                 ;
newline          :            NEWLINE
                     {createLeaf("newline", $ARG[1]);}
                 | SL_COMMENT NEWLINE
                     {createLeaf("comment", $ARG[1]);}
                 ;
newline_list     :              newline
                     {createNode("newline_list", $ARG[1]);}
                 | newline_list newline
                     {appendNode($ARG[1], $ARG[2]);}
                 ;
linebreak        : newline_list
                 | /* empty */
                 ;
separator_op     : '&'
                 | ';'
                 ;
separator        : separator_op linebreak
                     {$ARG[3];}
                 | newline_list
                 ;
sequential_sep   : ';' linebreak
                 | newline_list
                 ;
%%
