/* Mainly taken and modified from the POSIX shell standard:
   http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html */

%{
    use strict;
    use warnings;
    use English;
    use Switch;

    sub getNextToken {
        # Could use a trie for this, but too much effort
        # Could also use a regex, but is harder to maintain
        my @delimiters = ({
            # Single character delimiters
            " " => "SPACE",
            "\t" => "SPACE",
            "\n" => "NEWLINE",
            "#" => "SL_COMMENT",
            "\\" => "ESCAPE",
            "'" => "SQUOTE",
            "\"" => "DQUOTE",
            "|" => "|",
            ";" => ";",
            "&" => "&",
            "(" => "(",
            ")" => ")",
            ">" => ">",
            "<" => "<"
        }, {
            # Two character delimiters
            "&&" => "AND_IF",
            "||" => "OR_IF",
            ";;" => "DSEMI",
            "<<" => "DLESS",
            ">>" => "DGREAT",
            "<>" => "LESSGREAT"
        });

        # Find the next delimiter
        my ($nextDelim, $nextDelimType, $nextDelimIndex);
        $nextDelimIndex = length $ARG[0]->YYData->{"DATA"};
        if ($ARG[0]->YYData->{"DATA"} =~ /(\$(?:\\\n)?(?:[-@*#?\$!0-9]|[a-z_](?:\\\n|[a-z0-9_])*))/i) {
            # Special case for $variables, since they are treated as normal text if the name isn't valid
            $nextDelim = $1;
            $nextDelimType = "VARIABLE";
            $nextDelimIndex = $-[1];
        }
    findDelim:
        for (my $c = 0; $c < $nextDelimIndex; ++$c) {
            # Escaped newlines are interpreted as if they didn't exist except when in comments
            # e.g., They can be placed inside a two-character delimiter (copies bash's behavior)
            while (substr($ARG[0]->YYData->{"DATA"}, $c, 3) =~ s/^(?:[^\\#]\K)?\\\n//) {
                $nextDelimIndex -= 2;
            }

            for (my $delimLength = scalar @delimiters; $delimLength > 0; --$delimLength) {
                my $substr = substr($ARG[0]->YYData->{"DATA"}, $c, $delimLength);
                if ($delimiters[$delimLength - 1]->{$substr}) {
                    $nextDelim = $substr;
                    $nextDelimType = $delimiters[$delimLength - 1]->{$substr};
                    $nextDelimIndex = $c;
                    last findDelim;
                }
            }
        }

        if ($nextDelimIndex != 0) {
            # Another special case for variable assignments, with same reason as above
            $ARG[0]->YYData->{"DATA"} =~ s/^([a-z_][a-z0-9_]*)=//i and return ("VARIABLE_ASSIGNMENT", $1);

            # Delimiter isn't immediately next, so return the bit in between
            my $token = substr($ARG[0]->YYData->{"DATA"}, 0, $nextDelimIndex, "");

            # Check for reserved words
            my $type;
            switch ($token) {
                case "if" {$type = "If";}
                case "then" {$type = "Then";}
                case "else" {$type = "Else";}
                case "elif" {$type = "Elif";}
                case "fi" {$type = "Fi";}
                case "do" {$type = "Do";}
                case "done" {$type = "Done";}
                case "case" {$type = "Case";}
                case "esac" {$type = "Esac";}
                case "while" {$type = "While";}
                case "for" {$type = "For";}
                case "!" {$type = "Bang";}
                case "in" {$type = "In";}
                case m/^[a-z_][a-z0-9_]*$/i {$type = "NAME";}
                else {$type = "WORD";}
            }

            return ($type, $token);
        } elsif ($nextDelimType eq "SL_COMMENT") {
            # Comments go until the end of the line
            $ARG[0]->YYData->{"DATA"} =~ s/^(#.*)// and return ("SL_COMMENT", $1);
            die("Should never happen");
        } elsif ($nextDelimType eq "VARIABLE") {
            # Since a variable token is detected before the escaped newline removal, they have to be manually removed
            substr($ARG[0]->YYData->{"DATA"}, 0, length $nextDelim, "");
            $nextDelim =~ s/\\\n//g;
            return ("VARIABLE", substr($nextDelim, 1)); # Don't include the $
        } elsif ($nextDelimType eq "ESCAPE") {
            # If the stream ends before the escaped character, return nothing (not specified by POSIX, but is bash's behaviour)
            $ARG[0]->YYData->{"DATA"} =~ s/^\\(.)// and return ("ESCAPED", $1);
            $ARG[0]->YYData->{"DATA"} =~ /^\\\n/ and die("Should never happen");
            return ("", undef);
        } elsif ($nextDelimType eq "SQUOTE") {
            # Single quotes includes everything until the next single quote
            $ARG[0]->YYData->{"DATA"} =~ s/^'([^']*)'// and return ("WORD_SQUOTED", $1);
            error($ARG[0], "unexpected EOF while looking for matching `''");
            return ("", undef);
        } elsif ($nextDelimType eq "DQUOTE") {
            error($ARG[0], "Double quotes are currently not supported");
            return ("", undef);
        } elsif ($nextDelimType eq "SPACE") {
            die("Should never happen");
        } else {
            substr($ARG[0]->YYData->{"DATA"}, 0, length $nextDelim, "");
            return ($nextDelimType, $nextDelim);
        }
    }

    sub Lexer {
        my %reservedWordTypes = (
            "If" => 1,
            "Then" => 1,
            "Else" => 1,
            "Elif" => 1,
            "Fi" => 1,
            "Do" => 1,
            "Done" => 1,
            "Case" => 1,
            "Esac" => 1,
            "While" => 1,
            "For" => 1,
            "Bang" => 1,
            "In" => 1
        );
        my %otherWordTypes = (
            "NAME" => 1,
            "WORD" => 1,
            "WORD_SQUOTED" => 1,
            "WORD_DQUOTED" => 1,
            "VARIABLE" => 1,
            "VARIABLE_ASSIGNMENT" => 1,
            "ESCAPED" => 1
        );

        if (!$ARG[0]->YYData->{"queuedTokens"}) {
            $ARG[0]->YYData->{"queuedTokens"} = [];
        }
        if (scalar @{$ARG[0]->YYData->{"queuedTokens"}}) {
            return @{shift(@{$ARG[0]->YYData->{"queuedTokens"}})};
        }

        # Whitespace is ignored (outside of quotes)
        $ARG[0]->YYData->{"DATA"} =~ s/^([ \t]+)//;
        my $removedLeadingWhitespace = $1;

        if (length $ARG[0]->YYData->{"DATA"} == 0) {
            return ("", undef);
        }

        my ($tokenType, $tokenValue) = getNextToken($ARG[0]);

        # A new word starting with a reserved word and not a reserved word is marked as a normal word to help with parsing
        if ((!$ARG[0]->YYData->{"isInWord"} || $removedLeadingWhitespace) &&
            $reservedWordTypes{$tokenType} && $ARG[0]->YYData->{"DATA"} =~ /^[^ \t]/) {
            my ($nextTokenType, $nextTokenValue) = getNextToken($ARG[0]);
            if ($reservedWordTypes{$nextTokenType} || $otherWordTypes{$nextTokenType}) {
                $tokenType = "WORD";
                push(@{$ARG[0]->YYData->{"queuedTokens"}}, ["WORD_CONTINUATION", ""]);
            }
            push(@{$ARG[0]->YYData->{"queuedTokens"}}, [$nextTokenType, $nextTokenValue]);
        }

        # If this is the second "word" type token in a row, insert a WORD_CONTINUATION in between
        if ($reservedWordTypes{$tokenType} || $otherWordTypes{$tokenType}) {
            if (!$removedLeadingWhitespace && $ARG[0]->YYData->{"isInWord"}) {
                push(@{$ARG[0]->YYData->{"queuedTokens"}}, [$tokenType, $tokenValue]);
                return ("WORD_CONTINUATION", "");
            } else {
                $ARG[0]->YYData->{"isInWord"} = 1;
            }
        } else {
            $ARG[0]->YYData->{"isInWord"} = 0;
        }

        return ($tokenType, $tokenValue);
    }

    sub createNode {
        my $type = shift @ARG;
        return {
            "type" => $type,
            "children" => \@ARG
        };
    }
    sub createLeaf {
        return {
            "type" => $ARG[0],
            "value" => $ARG[1]
        };
    }
    sub appendNode {
        my $node = shift @ARG;
        push $node->{"children"}, @ARG;
        return $node;
    }

    sub mergeCommand {
        my $result = shift @ARG;
        foreach my $arg (@ARG) {
            foreach my $key (keys %$arg) {
                if (!$result->{$key}) {
                    $result->{$key} = $arg->{$key};
                } else {
                    die("Merge conflict: $key\n");
                }
            }
        }
        return $result;
    }

    sub error {
        print STDERR "Error: ", $ARG[1], "\n";
        $ARG[0]->YYError();
    }
%}

/* -------------------------------------------------------
   The grammar symbols
   ------------------------------------------------------- */
%token  WORD
%token  WORD_SQUOTED
%token  WORD_CONTINUATION
%token  NAME
%token  NEWLINE
%token  SL_COMMENT

%token  HERE_STRING
%token  VARIABLE
%token  VARIABLE_ASSIGNMENT
%token  ESCAPED

/* The following are the operators mentioned above. */

%token  AND_IF    OR_IF    DSEMI
/*      '&&'      '||'     ';;'    */

%token  DLESS  DGREAT  LESSGREAT
/*      '<<'   '>>'    '<>'      */


/* The following are the reserved words. */

%token  If    Then    Else    Elif    Fi    Do    Done
/*      'if'  'then'  'else'  'elif'  'fi'  'do'  'done'   */


%token  Case    Esac    While    For
/*      'case'  'esac'  'while'  'for'   */


/* These are reserved words, not operator tokens, and are
   recognized when reserved words are recognized. */

%token  Bang
/*      '!'   */


%token  In
/*      'in'   */

/* -------------------------------------------------------
   The Grammar
   ------------------------------------------------------- */
%start file
%%
file             : list_opt_sep
                 | linebreak
                     {createNode("list", $ARG[1]);}
                 ;
list_no_sep      :             linebreak and_or
                     {createNode("list", $ARG[1], $ARG[2]);}
                 | list_no_sep separator and_or
                     {appendNode($ARG[1], $ARG[2], $ARG[3]);}
                 ;
list             : list_no_sep separator
                     {appendNode($ARG[1], $ARG[2]);}
                 ;
list_opt_sep     : list
                 | list_no_sep
                 ;
and_or           :                         pipeline
                     {createNode("and_or", $ARG[1]);}
                 | and_or AND_IF linebreak pipeline
                     {createNode("and_or", $ARG[1], $ARG[2], $ARG[3], $ARG[4]);}
                 | and_or OR_IF  linebreak pipeline
                     {createNode("and_or", $ARG[1], $ARG[2], $ARG[3], $ARG[4]);}
                 ;
pipeline         :      pipe_sequence
                     {$ARG[1];}
                 | Bang pipe_sequence
                     {createLeaf("not", $ARG[2]);}
                 ;
pipe_sequence    :                             command
                     {createNode("pipe_sequence", $ARG[1]);}
                 | pipe_sequence '|' linebreak command
                     {appendNode($ARG[1], $ARG[3], $ARG[4]);}
                 ;
command          : simple_command
                     {createLeaf("simple_command", $ARG[1]);}
                 | compound_command
                     {createLeaf("compound_command", $ARG[1]);}
                 | compound_command redirect_list
                     {error($ARG[0], "IO redirection currently unsupported");}
                 ;
compound_command : for_clause
                     {createLeaf("for", $ARG[1]);}
                 | case_clause
                     {createLeaf("case", $ARG[1]);}
                 | if_clause
                     {createLeaf("if", $ARG[1]);}
                 | while_clause
                     {createLeaf("while", $ARG[1]);}
                 ;
for_clause       : For NAME                                      do_group
                     {{"var" => $ARG[2], "in" => ["\$@"], "action" => $ARG[3]};}
                 | For NAME                       sequential_sep do_group
                     {{"var" => $ARG[2], "in" => ["\$@"], "comments" => $ARG[3], "action" => $ARG[4]};}
                 | For NAME linebreak In          sequential_sep do_group
                     {{"var" => $ARG[2], "in" => [], "comments" => $ARG[5], "action" => $ARG[6]};}
                 | For NAME linebreak In wordlist sequential_sep do_group
                     {{"var" => $ARG[2], "in" => $ARG[5], "comments" => $ARG[6], "action" => $ARG[7]};}
                 ;
case_clause      : Case word linebreak In linebreak case_list    Esac
                     {
                         push($ARG[3]->{"children"}, @{$ARG[5]->{"children"}});
                         {"word" => $ARG[2], "comments" => $ARG[3], "cases" => $ARG[6]};
                     }
                 | Case word linebreak In linebreak case_list_ns Esac
                     {
                         push($ARG[3]->{"children"}, @{$ARG[5]->{"children"}});
                         {"word" => $ARG[2], "comments" => $ARG[3], "cases" => $ARG[6]};
                     }
                 | Case word linebreak In linebreak              Esac
                     {
                         push($ARG[3]->{"children"}, @{$ARG[5]->{"children"}});
                         {"word" => $ARG[2], "comments" => $ARG[3]};
                     }
                 ;
case_list_ns     : case_list case_item_ns
                     {push $ARG[1], $ARG[2]; $ARG[1];}
                 |           case_item_ns
                     {[$ARG[1]];}
                 ;
case_list        : case_list case_item
                     {push $ARG[1], $ARG[2]; $ARG[1];}
                 |           case_item
                     {[$ARG[1]];}
                 ;
case_item_ns     :     pattern ')'      linebreak
                     {{"case" => $ARG[1], "comments" => $ARG[3]};}
                 |     pattern ')' list linebreak
                     {{"case" => $ARG[1], "action" => $ARG[3], "comments" => $ARG[4]};}
                 | '(' pattern ')'      linebreak
                     {{"case" => $ARG[2], "comments" => $ARG[4]};}
                 | '(' pattern ')' list linebreak
                     {{"case" => $ARG[2], "action" => $ARG[4], "comments" => $ARG[5]};}
                 ;
case_item        :     pattern ')' linebreak    DSEMI linebreak
                     {
                         push($ARG[3]->{"children"}, @{$ARG[5]->{"children"}});
                         {"case" => $ARG[1], "comments" => $ARG[3]};
                     }
                 |     pattern ')' list_opt_sep DSEMI linebreak
                     {{"case" => $ARG[1], "action" => $ARG[3], "comments" => $ARG[5]};}
                 | '(' pattern ')' linebreak    DSEMI linebreak
                     {
                         push($ARG[4]->{"children"}, @{$ARG[6]->{"children"}});
                         {"case" => $ARG[2], "comments" => $ARG[4]};
                     }
                 | '(' pattern ')' list_opt_sep DSEMI linebreak
                     {{"case" => $ARG[2], "action" => $ARG[4], "comments" => $ARG[6]};}
                 ;
pattern          :             word
                     {[$ARG[1]];}
                 | pattern '|' word
                     {push $ARG[1], $ARG[2]; $ARG[1];}
                 ;
if_clause        : If list Then list else_part Fi
                     {{"condition" => $ARG[2], "then" => $ARG[4], "else" => $ARG[5]};}
                 | If list Then list           Fi
                     {{"condition" => $ARG[2], "then" => $ARG[4]};}
                 ;
else_part        : Elif list Then list else_part
                     {{"condition" => $ARG[2], "then" => $ARG[4], "else" => $ARG[5]};}
                 | Elif list Then list
                     {{"condition" => $ARG[2], "then" => $ARG[4]};}
                 | Else list
                     {$ARG[2];}
                 ;
while_clause     : While list do_group
                     {{"condition" => $ARG[2], "then" => $ARG[3]};}
                 ;
do_group         : Do list Done
                     {$ARG[2];}
                 ;
simple_command   : cmd_prefix word_no_assign cmd_suffix
                     {mergeCommand($ARG[1], $ARG[3], {"command" => $ARG[2]});}
                 | cmd_prefix word_no_assign
                     {mergeCommand($ARG[1], {"command" => $ARG[2]});}
                 | cmd_prefix
                 | word_no_assign cmd_suffix
                     {mergeCommand($ARG[2], {"command" => $ARG[1]});}
                 | word_no_assign
                     {{"command" => $ARG[1]};}
                 ;
cmd_prefix       :            io_redirect
                     {error($ARG[0], "IO redirection currently unsupported");}
                 | cmd_prefix io_redirect
                     {error($ARG[0], "IO redirection currently unsupported");}
                 |            assignment_word
                     {{"assignment" => [$ARG[1]]};}
                 | cmd_prefix assignment_word
                     {push $ARG[1]->{"assignment"}, $ARG[2]; $ARG[1];}
                 ;
cmd_suffix       :            io_redirect
                     {error($ARG[0], "IO redirection currently unsupported");}
                 | cmd_suffix io_redirect
                     {error($ARG[0], "IO redirection currently unsupported");}
                 |            word_or_reserved
                     {{"args" => [$ARG[1]]}}
                 | cmd_suffix word_or_reserved
                     {push $ARG[1]->{"args"}, $ARG[2]; $ARG[1];}
                 ;
redirect_list    :               io_redirect
                 | redirect_list io_redirect
                 ;
io_redirect      : io_file
                 | DLESS HERE_STRING
                 ;
io_file          : '<'       word
                 | '>'       word
                 | DGREAT    word
                 | LESSGREAT word
                 ;
newline          : NEWLINE
                 | SL_COMMENT
                 ;
newline_list     :              newline
                     {createNode("newline_list", $ARG[1]);}
                 | newline_list newline
                     {appendNode($ARG[1], $ARG[2]);}
                 ;
linebreak        : newline_list
                 | /* empty */
                     {createNode("newline_list");}
                 ;
separator_op     : '&'
                 | ';'
                 ;
separator        : separator_op linebreak
                     {$ARG[2];}
                 | newline_list
                 ;
sequential_sep   : ';' linebreak
                     {$ARG[2];}
                 | newline_list
                 ;

/* Word definition aka quote/variable/escape parsing */
wordlist         :          word
                     {createNode("wordlist", $ARG[1]);}
                 | wordlist word
                     {appendNode($ARG[1], $ARG[2]);}
                 ;
word_or_reserved : word
                 | reserved_word
                     {createNode("word", $ARG[1]);}
                 ;
word             : word_no_assign
                 | assignment_word
                 ;
word_no_assign   :                                  word_part
                     {createNode("word", $ARG[1]);}
                 | word_no_assign WORD_CONTINUATION word_part
                     {appendNode($ARG[1], $ARG[3]);}
                 | word_no_assign WORD_CONTINUATION reserved_word
                     {appendNode($ARG[1], $ARG[3]);}
                 | word_no_assign WORD_CONTINUATION VARIABLE_ASSIGNMENT
                     {appendNode($ARG[1], $ARG[3] . "=");}
                 ;
word_part        : WORD
                 | WORD_SQUOTED
                 | VARIABLE
                     {createLeaf("variable", $ARG[1]);}
                 | NAME
                 | ESCAPED
                 ;
reserved_word    : If
                 | Then
                 | Else
                 | Elif
                 | Fi
                 | Do
                 | Done
                 | Case
                 | Esac
                 | While
                 | For
                 | Bang
                 | In
                 ;
assignment_word  : VARIABLE_ASSIGNMENT WORD_CONTINUATION word
                     {{"var" => $ARG[1], "value" => $ARG[3]};}
                 | VARIABLE_ASSIGNMENT
                     {{"var" => $ARG[1]};}
                 ;
%%
